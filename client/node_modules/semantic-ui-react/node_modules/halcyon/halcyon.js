(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  factory((global.halcyon = {}));
}(this, function (exports) { 'use strict';

  function _mapList (fn, xs) {
    var res = new Array(xs.length)
      , i   = 0

    for (; i < xs.length; i++) {
      res[i] = fn(xs[i])
    }
    return res
  }

  function stringifyFn (fn) {
    return fn.displayName || fn.name || fn.toString()
  }

  // TODO(zuko): we should perform better stringification for complex values.
  function stringifyArgument (x) {
    return Array.isArray(x) ? '[' + x.map(stringifyArgument).join(', ') + ']' :
           typeof x === 'function' ? stringifyFn(x) :
           JSON.stringify(x)
  }

  function _createFnName (name, args) {
    if (!args.length) return name
    return (
      name +
      '(' +
      _mapList(stringifyArgument, args).join(', ') +
      ')'
    )
  }

  function _nameFunc (name, fn) {
    Object.defineProperty(fn, 'name', { value: name })
    Object.defineProperty(fn, 'displayName', {
      value: name
    , configurable: true
    , enumerable: false
    })
    fn.toString = function () {
      return name
    }
    return fn
  }

  function _arity (arity, fn) {
    if (Object.getOwnPropertyDescriptor(fn, 'length').writable) {
      Object.defineProperty(fn, 'length', { value: arity })
      return fn
    }
    // Credit to Ramda for this idea for creating curried functions that
    // properly report their arity via function.length.
    // https://github.com/ramda/ramda/blob/master/src/internal/_arity.js
    switch (arity) {
      case 0: return function () { return fn.apply(null, arguments) }
      case 1: return function (a0) { return fn.apply(null, arguments) }
      case 2: return function (a0, a1) { return fn.apply(null, arguments) }
      case 3: return function (a0, a1, a2) { return fn.apply(null, arguments) }
      case 4: return function (a0, a1, a2, a3) { return fn.apply(null, arguments) }
      case 5: return function (a0, a1, a2, a3, a4) { return fn.apply(null, arguments) }
      case 6: return function (a0, a1, a2, a3, a4, a5) { return fn.apply(null, arguments) }
      default: throw new Error('Function arity must be <= 6.')
    }
  }

  var _slice = [].slice

  /**
   * @description
   * Curries a function to the specified arity. Receives a list of arguments
   * to treat as as already-supplied (meaning they count toward fulfilling
   * the target arity). The resulting function will combine the existing
   * arguments with those from the latest call, and if the resulting length
   * is greater than or equal to the target arity, the original function will
   * be called with those arguments. If the number of arguments is still
   * smaller than the required amount, the function will be curried again.
   */
  function _curryN (arity, args, fn) {
    var fnWrapper = _arity(arity, function () {
      var nextArgs  = args
        , nextArity = arity - arguments.length
        , i

      if (arguments.length) {
        nextArgs = _slice.call(nextArgs)
        for (i = 0; i < arguments.length; i++) {
          nextArgs[nextArgs.length] = arguments[i]
        }
      }

      return nextArity <= 0
        ? fn.apply(null, nextArgs)
        : _curryN(nextArity, nextArgs, fn)
    })
    _nameFunc(_createFnName(fn.displayName || fn.name, args), fnWrapper)
    return fnWrapper
  }

  function _defn (name, fn) {
    var arity = fn.length

    switch (arity) {
      case 0:
      case 1:
        return _nameFunc(name, _arity(arity, fn))
      default:
        return _curryN(arity, [], _nameFunc(name, fn))
    }
  }

  /**
   * @name add
   * @signature Number -> Number -> Number
   * @since v0.1.0
   * @description
   * Returns the sum of two numbers.
   * @see subtract
   *
   * @example
   * add(1, 2) // => 3
   *
   * const add5 = add(5)
   * add5(10) // => 15
   * add5(15) // => 20
   */
  var add = _defn('add', function (a, b) {
    return a + b
  })

  /**
   * @name all
   * @signature (a -> Boolean) -> [a] -> Boolean
   * @since v0.7.0
   * @description
   * Tests a predicate against all items in a list. Returns true if the predicate
   * returns true for all items in the list, otherwise returns false. If the list
   * is empty it will return true ([vacuous truth](https://en.wikipedia.org/wiki/Vacuous_truth)).
   * @see any
   *
   * @example
   * all(isEven, [2, 4, 6, 8]) // => true
   * all(isEven, [2, 4, 6, 3]) // => false, 3 is not an even number
   * all(isEven, [])           // => true
   */
  var all = _defn('all', function (fn, xs) {
    var i   = 0
      , len = xs.length

    for (; i < len; i++) {
      if (!fn(xs[i])) {
        return false
      }
    }
    return true
  })

  /**
   * @name always
   * @signature a -> Any -> a
   * @since v0.9.0
   * @description
   * Takes a single argument and returns a function that, when invoked, always
   * returns that original argument.
   *
   * @example
   * const alwaysTrue = always(true) // => function
   * alwaysTrue()         // => true
   * alwaysTrue(false)    // => true
   * times(alwaysTrue, 5) // => [true, true, true, true, true]
   */
  var always = _defn('always', function (x) {
    return function () {
      return x
    }
  })

  /**
   * @name any
   * @signature (a -> Boolean) -> [a] -> Boolean
   * @since v0.7.0
   * @description
   * Tests a predicate against all items in a list. Returns true if the predicate
   * returns true for any item, otherwise returns false. Short circuits once
   * a true condition is found. If the list is empty it will return false.
   * @see all
   *
   * @example
   * any(isEven, [1, 2, 3, 4, 5]) // => true, 2 is an even number
   * any(isEven, [1, 3, 5])       // => false, no numbers are even
   * any(isEven, [])              // => false
   */
  var any = _defn('any', function (fn, xs) {
    var i = 0

    for (; i < xs.length; i++) {
      if (fn(xs[i])) {
        return true
      }
    }
    return false
  })

  var _concat = [].concat

  /**
   * @name append
   * @signature
   * a -> [a] -> [a]
   * String -> String -> String
   * @since v0.10.0
   * @description
   * Appends a single element to a list. If the argument in list position is a
   * string, string concatenation will be used instead.
   * @see prepend
   * @see concat
   *
   * @example
   * append(4, [1, 2, 3])      // => [1, 2, 3, 4]
   * append([4, 5], [1, 2, 3]) // => [1, 2, 3, [4, 5]]
   * append('bar', 'foo')      // => 'foobar'
   */
  var append = _defn('append', function (x, xs) {
    if (typeof xs === 'string') {
      return xs + x
    }
    return _concat.call(xs, [x])
  })

  /**
   * @name assoc
   * @signature String k, Any v => k -> v -> {k:v} -> {k:v}
   * @since v0.6.0
   * @description
   * Applies a value to a given key on an object. You can think of `assoc` as
   * the process of _associating_ a key with a value.
   * Note that the original object is not mutated; a shallow copy is returned.
   * @see dissoc
   * @example
   * const user = { first: 'Chris', last: 'Loblaw' }
   * assoc('first', 'Bob', user) // => { first: 'Bob', last: 'LobLaw' }
   */
  var assoc = _defn('assoc', function (k, v, o) {
    var y = {}
      , p

    for (p in o) y[p] = o[p]
    y[k] = v
    return y
  })

  /**
   * @name chain
   * @signature (a -> [b]) -> [a] -> [b]
   * @since v0.1.0
   * @description
   * Maps over a list and concatenates the results as it goes; this is also
   * known as `flatMap`, and is generally equivalent to:
   * `_.flatten(_.map(yourFn, yourList))`.
   *
   * Note that this does not currently dispatch to the `chain` method on
   * the argument in list position.
   * @example
   * chain(x => [x, x * 2], [1, 2, 3, 4]) // => [1, 2, 2, 4, 3, 6, 4, 8]
   */
  var chain = _defn('chain', function (fn, xs) {
    var i   = 0
      , res  = []
      , x
      , xi

    for (; i < xs.length; i++) {
      x = fn(xs[i])
      if (Array.isArray(x)) {
        for (xi = 0; xi < x.length; xi++) {
          res[res.length] = x[xi]
        }
      } else {
        res[res.length] = x
      }
    }

    return res
  })

  /**
   * @name clamp
   * @signature Number -> Number -> Number -> Number
   * @since v0.18.0
   * @description
   * Restricts a value to a given range (inclusive).
   * @example
   * clamp(1, 10, 5)  // => 5
   * clamp(1, 10, -5) // => 1
   * clamp(1, 10, 15) // => 10
   */
  var clamp = _defn('clamp', function (lower, upper, value) {
    return value < lower ? lower :
           value > upper ? upper :
           value
  })

  /**
   * @name concat
   * @signature
   * [a] -> [a] -> [a]
   * String -> String -> String
   * @since v0.7.0
   * @description
   * Concatenates two values together by dispatching to the `concat` method of
   * the first argument. This is most commonly used for Array and String
   * concatenation.
   *
   * @example
   * concat([1, 2, 3], [4, 5, 6]) // => [1, 2, 3, 4, 5, 6]
   * concat([1, 2, 3], [])        // => [1, 2, 3]
   * concat('foo', 'bar')         // => 'foobar'
   */
  // TODO(zuko): consider flipping argument order, breaking change
  var concat = _defn('concat', function (xs, ys) {
    return xs.concat(ys)
  })

  /**
   * @name cond
   * @signature [[(a -> Boolean), (a -> b)]] -> a -> b | undefined
   * @since v0.12.0
   * @description
   * Takes a series of conditions, expressed by tuples which contain two
   * functions, a predicate and a handler, and returns a function that applies
   * its arguments to each condition's predicate until one returns true. When
   * that happens, that condition's handler function is called with the same
   * arguments and its result is returned.
   * If no predicate is matched `undefined` is returned. It is common to use `T`
   * -- shorthand for `always(true)` -- as the last condition to act as a final
   * else clause.
   * @see ifElse
   * @see when
   * @see unless
   *
   * @example
   * const fizzbuzz = cond([
   *  [x => x % 15 === 0, always('FizzBuzz')],
   *  [x => x % 3 === 0, always('Fizz')],
   *  [x => x % 5 === 0, always('Buzz')],
   *  [T, identity]
   * ])
   *
   * map(fizzbuzz, [1, 2, 3, 4, 5]) // => [1, 2, 'Fizz', 4, 'Buzz']
   */
  var cond = _defn('cond', function (conditions, a) {
    var i = 0

    for (; i < conditions.length; i++) {
      if (conditions[i][0](a)) {
        return conditions[i][1](a)
      }
    }
  })

  var _toString = Object.prototype.toString

  function _type (x) {
    if (x == null) return 'Nil'

    return _toString.call(x).slice(8, -1)
  }

  /**
   * @name type
   * @signature a -> String
   * @since v0.13.0
   * @description
   * Returns the string representation of an argument. Note that this function
   * provides certain conveniences: `null` and `undefined` are both treated
   * as `Nil`, and promises return `Promise` rather than `Object`.
   *
   * @example
   * type(1)                 // => 'Number'
   * type('hello')           // => 'String'
   * type(true)              // => 'Boolean'
   * type({})                // => 'Object'
   * type([])                // => 'Array'
   * type(Promise.resolve()) // => 'Promise'
   * type(undefined)         // => 'Nil'
   * type(null)              // => 'Nil'
   */
  var typeOf = _defn('type', _type)

  function _iteratorToArray (iterator) {
    var result = []
      , len    = result.length
      , next   = iterator.next()

    while (!next.done) {
      result[len++] = next
      next = iterator.next()
    }
    return next
  }

  var _hasOwn = Object.prototype.hasOwnProperty

  // Conform to SameValueZero algorithm:
  // http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero
  function _identical (a, b) {
    return a === b || (a !== a && b !== b) // eslint-disable-line
  }

  function _compareObjects (a, b) {
    var aKeys
      , keysIdx
      , key

    aKeys = Object.keys(a)
    if (aKeys.length !== Object.keys(b).length) return false

    // cheap check to confirm that objects share the same keys
    keysIdx = aKeys.length - 1
    while (keysIdx >= 0) {
      if (!_hasOwn.call(b, aKeys[keysIdx])) return false
      keysIdx -= 1
    }
    // compare values at each key
    keysIdx = aKeys.length - 1
    while (keysIdx >= 0) {
      key = aKeys[keysIdx]
      if (!_equals(a[key], b[key])) return false
      keysIdx -= 1
    }
    return true
  }

  function _equals (a, b) {
    var aEntries
      , bEntries

    if (_identical(a, b)) return true
    if (typeOf(a) !== typeOf(b)) return false

    // We now know that a and b are the same type. If they are primitives
    // or null or undefined, we return false because they were not
    // identical and there is no further comparison to make.
    if (!a || !b || typeof a !== 'object') return false
    switch (typeOf(a)) {
      case 'Array':
        if (a.length !== b.length) return false
        return _compareObjects(a, b)
      case 'Date':
        return a.valueOf() === b.valueOf()
      case 'Promise':
        return a === b
      case 'Map':
      case 'Set':
        aEntries = _iteratorToArray(a.entries())
        bEntries = _iteratorToArray(b.entries())
        return aEntries.length === bEntries.length && _equals(aEntries, bEntries)
      // All object types require a deep comparison
      default:
        return _compareObjects(a, b)
    }
  }

  function contains$1 (x, xs) {
    var i

    if (typeof xs === 'string') {
      return xs.indexOf(x) !== -1
    }

    i = xs.length - 1
    while (i >= 0) {
      if (_equals(x, xs[i])) {
        return true
      }
      i--
    }
    return false
  }

  /**
   * @name contains
   * @signature
   * a -> [a] -> Boolean
   * String -> String -> Boolean
   * @since v0.14.0
   * @description
   * Returns whether or not a list contains the target value. Performs a
   * deep equality comparison when looking up objects.
   *
   * @example
   * contains(1, [1, 2, 3, 4])                   // => true
   * contains(5, [1, 2, 3, 4])                   // => false
   * contains({ id: 1 }, [{ id: 1 }, { id: 2 }]) // => true
   * contains('foo', 'foobarbaz')                // => true
   */
  var contains = _defn('contains', contains$1)

  /**
   * @name identity
   * @signature a -> a
   * @since v0.6.0
   * @description
   * Unary function that returns the argument it receives. Useful for when
   * you simply want to forward an argument along.
   *
   * @example
   * identity(5) // => 5
   *
   * const doubleIfEven = when(isEven, multiply(2))
   * doubleIfEven(2) // => 4
   * doubleIfEven(3) // => 3
   */
  var identity = _defn('identity', function (a) {
    return a
  })

  function filterList (pred, xs) {
    var i   = 0
      , res = []

    while (i < xs.length) {
      if (pred(xs[i])) {
        res[res.length] = xs[i]
      }
      i++
    }
    return res
  }

  function keys$1 (obj) {
    return Object.keys(obj)
  }

  function _reduce (fn, acc, xs) {
    var i = 0

    for (; i < xs.length; i++) {
      acc = fn(acc, xs[i])
    }
    return acc
  }

  function filterObject (pred, obj) {
    return _reduce(function (acc, key) {
      if (pred(obj[key])) acc[key] = obj[key]
      return acc
    }, {}, keys$1(obj))
  }

  /**
   * @name isType
   * @signature (String | Function) -> Boolean
   * @since v0.13.0
   * @description
   * Returns whether or not a value is of an expected. If the provided type is
   * a string, a `typeof` check is used. If a constructor is passed it will
   * be compared against the value's constructor.
   *
   * @example
   * const isString = isType('string')
   *
   * isString('hello!')    // => true
   * isType('number', 123) // => true
   */
  var isType = _defn('isType', function (type, a) {
    if (type == null) {
      return typeof type === typeof a
    }

    return typeof type === 'string'
      ? typeOf(a).toLowerCase() === type.toLowerCase()
      : a instanceof type || a.constructor === type
  })

  /**
   * @name filter
   * @signature
   * (a -> Boolean) -> [a] -> [a]
   * String k, Any v => (v -> Boolean) -> {k:v} -> {k:v}
   * @since v0.1.0
   * @description
   * Filters a list by calling the predicate function with each element in the
   * list. If the predicate returns a truthy value, the element is kept in
   * the new list, otherwise it is discarded.
   * @see reject
   *
   * @example
   * filter(isEven, [1, 2, 3, 4, 5]) // => [2, 4]
   */
  var filter = _defn('filter', function (pred, xs) {
    return isType('Object', xs)
      ? filterObject(pred, xs)
      : filterList(pred, xs)
  })

  /**
   * @name compact
   * @signature
   * [a] -> [a]
   * String k, Any v => {k:v} -> {k:v}
   * @description
   * Removes all falsy values from a list. For objects, dissociates all
   * properties with falsy values.
   *
   * @example
   * compact([null, undefined, true, false]) // => [true]
   * compact({ a: false, b: null, c: true }) // => { c: true }
   * compact(['', 0, {}, [], '0'])           // => [{}, [], '0']
   */
  var compact = _defn('compact', filter(identity))

  /**
   * @name curryN
   * @signature Integer N => N -> (a1, a2, ..., aN -> v) -> a1 -> a2 -> ... -> aN -> v
   * @description
   * Curries a function to the provided arity, regardless of its actual arity.
   * @see curry
   *
   * @example
   * const fn = curryN(3, (...args) => console.log(args))
   *
   * fn(1)       // => Function
   * fn(1)(2)    // => Function
   * fn(1, 2, 3) // => [1, 2, 3]
   * fn(1)(2)(3) // => [1, 2, 3]
   */
  var curryN = _defn('curryN', function (arity, fn) {
    return _curryN(arity, [], fn)
  })

  /**
   * @name complement
   * @signature (*... -> Boolean) -> (*... -> Boolean)
   * @since v0.13.0
   * @description
   * Wraps a function and returns a new function, when called, invokes the
   * original function and returns the complement of its result. For example,
   * if the original function were to return `true` its complement would return
   * `false`.
   *
   * @example
   * isEven(2) // => true
   * complement(isEven)(2) // => false
   *
   * const isOdd = complement(isEven)
   * isOdd(3) // => true
   */
  var complement = _defn('complement', function (x) {
    return curryN(x.length, function () {
      return !x.apply(null, arguments)
    })
  })

  var _reverse = [].reverse

  /**
   * @name pipe
   * @signature [(a -> b), (b -> c), ... (y -> z)] -> a -> z
   * @since v0.1.0
   * @description
   * Takes a list of functions and creates a single, curried function
   * that, when called, invokes the original functions from left to right,
   * passing the result of each function call as the argument to the next. The
   * result of the rightmost function call is the final return value.
   * This is the same concept as `compose`, but runs the functions from
   * left -> right. Note that all functions except for the first (leftmost) must
   * be unary (accept only a single argument), because functions can only return
   * a single value.
   * @see compose
   *
   * @example
   * const getFriends = pipe([
   *  prop('friends'),
   *  map(pipe([prop('name'), toUpper])),
   *  join(', ')
   * ])
   *
   * const user = { friends: [{ name: 'Jim' }, { name: 'Dwight' }] }
   * getFriends(user) // => 'JIM, DWIGHT'
   */
  var pipe = _defn('pipe', function (fns) {
    var fni = 0
      , wrappedFn

    // TODO(zuko): abstract for use in other functions and disable in production.
    for (; fni < fns.length; fni++) {
      if (!isType('function', fns[fni])) {
        throw new TypeError(
          'Invalid argument supplied to `pipe`. The value at index ' +
          '[' + fni + '] was not a function; what was received was of type: ' +
          typeOf(fns[fni]) + '.'
        )
      }
    }
    wrappedFn = _curryN(fns[0].length, [], function () {
      var i   = 0
        , len = fns.length
        , acc = fns[i++].apply(null, arguments)

      for (; i < len; i++) {
        acc = fns[i](acc)
      }
      return acc
    })
    _nameFunc('pipe', [fns], wrappedFn)
    return wrappedFn
  })

  /**
   * @name compose
   * @signature [(y -> z), ..., (b -> c), (a -> b)] -> a -> z
   * @since v0.1.0
   * @description
   * Takes a list of functions and wraps them in a single, curried function
   * that, when called, invokes the original functions from right to left,
   * passing the result of each function call as the argument to the next. The
   * result of the leftmost function call is the final return value.
   * This is the same concept as `pipe`, but runs the functions from right -> left.
   * Note that all functions except for the first (rightmost) must be unary
   * (accept only a single argument), because functions can only return a single
   * value.
   * @see pipe
   *
   * @example
   * // Composes `sqrt` and `isEven` to produce a function that invokes the
   * // rightmost function (`sqrt`) with the arguments supplied to the composed
   * // function. The result of that function call is then used as the argument
   * // to the next function, `isEven`. Because `isEven` is the last function in
   * // the composition, its result is the final return value.
   * // This would look like: (x) => isEven(sqrt(x))
   * const isSqrtEven = compose([isEven, Math.sqrt])
   *
   * isSqrtEven(16) // => true
   */
  var compose = _defn('compose', function (fns) {
    var i = 0

    // TODO(zuko): abstract for use in other functions and disable in production.
    for (; i < fns.length; i++) {
      if (!isType('function', fns[i])) {
        throw new TypeError(
          'Invalid argument supplied to `compose`. The value at index ' +
          '[' + i + '] was not a function; what was received was of type: ' +
          typeOf(fns[i]) + '.'
        )
      }
    }
    return pipe(_reverse.call(fns))
  })

  /**
   * @name curry
   * @signature (a, b, ..., j -> v) -> a -> b -> ... -> j -> v
   * @since v0.1.0
   * @description
   * Curries a function based on its arity, which is determined via its `length`
   * property. Curried functions continue to accept arguments up until the number
   * of total arguments supplied to it meet or exceed its arity, at which point
   * the original function is called with those arguments.
   * If you wish to curry a function to a different or fixed arity, such as with
   * variadic functions, use [curryN](#curryn).
   * @see curryN
   *
   * @example
   * const add = curry((a, b, c) => a + b + c)
   * add(5)        // => Function
   * add(5, 10, 2) // => 17
   * add(5)(2)(3)  // => 10
   *
   * const add5 = add(5)
   * add5(3, 2) // => 10
   *
   * const add7 = add(5, 2)
   * add7(3) // => 10
   *
   * const add8 = add5(3)
   * add8(2) // => 10
   * add8(0) // => 8
   */
  var curry = _defn('curry', function (fn) {
    return curryN(fn.length, fn)
  })

  /**
   * @name dec
   * @signature Number -> Number
   * @since v0.6.0
   * @description
   * Decrements a number by `1`.
   * @see inc
   *
   * @example
   * dec(10) // => 9
   * dec(-1) // => -2
   */
  var dec = _defn('dec', function (a) {
    return a - 1
  })

  /**
   * @name dissoc
   * @signature String k, Any v => k -> {k:v} -> {k:v}
   * @since v0.10.0
   * @description
   * Removes a given key from an object. You can think of `dissoc` as the
   * process of _dissociating_ a key from an object. A shallow copy of the
   * original object is always returned, regardless of whether or not the
   * key existed.
   *
   * @example
   * const user = { first: 'Bob', last: 'Loblaw' }
   * dissoc('first', user) // => { last: 'Loblaw' }
   */
  var dissoc = _defn('dissoc', function (k, kv) {
    var y = {}
      , p

    for (p in kv) {
      if (p !== k) {
        y[p] = kv[p]
      }
    }
    return y
  })

  /**
   * @name divide
   * @signature Number -> Number -> Number
   * @since v0.14.0
   * @description
   * Returns the result of the second argument divided by the first. Because
   * infix notation with `/` is generally used when both arguments are known
   * upfront, we optimize for readability with partial application.
   *
   * @example
   * divide(2, 8) // => 4 (divide 8 by 2)
   *
   * @example
   * map(divide(2), [2, 4, 6, 8]) // => [1, 2, 3, 4]
   */
  var divide = _defn('divide', function (a, b) {
    if (!a) {
      throw new Error('Cannot divide by 0.')
    }

    return b / a
  })

  /**
   * @name drop
   * @signature Integer -> [a] -> [a]
   * @since v0.10.0
   * @description
   * Returns a list with the first N elements removed. If N exceeds the length
   * of the list, an empty list will be returned.
   *
   * @example
   * drop(2, [1, 2, 3, 4]) // => [3, 4]
   */
  var drop = _defn('drop', function (n, xs) {
    return _slice.call(xs, n)
  })

  /**
   * @name dropUntil
   * @signature (a -> Boolean) -> [a] -> [a]
   * @since v0.14.0
   * @description
   * Runs a predicate function sequentially through a list, dropping
   * all elements until the predicate returns `true`. Once the predicate
   * returns `true`, the remainder of the list is returned.
   * @see dropWhile
   *
   * @example
   * const isEven = x => x % 2 === 0
   *
   * dropUntil(isEven, [1, 3, 6, 8, 10]) // => [6, 8, 10]
   * dropUntil(isEven, [1, 3, 6, 5, 7])  // => [6, 5, 7]
   */
  var dropUntil = _defn('dropUntil', function (fn, xs) {
    var i = 0

    while (i < xs.length && !fn(xs[i])) i += 1
    return _slice.call(xs, i)
  })

  /**
   * @name dropWhile
   * @signature (a -> Boolean) -> [a] -> [a]
   * @since v0.14.0
   * @description
   * Runs a predicate function sequentially through a list, dropping
   * all elements until the predicate returns `false`. Once the predicate
   * returns `false`, the remainder of the list is returned. This can
   * be thought of as `dropUntil(complement(predicate))`.
   * @see dropUntil
   *
   * @example
   * dropWhile(isEven, [2, 4, 6, 7, 8]) // => [7, 8]
   */
  var dropWhile = _defn('dropWhile', function (fn, xs) {
    var i = 0

    while (i < xs.length && fn(xs[i])) i += 1
    return _slice.call(xs, i)
  })

  /**
   * @name empty
   * @signature a -> a
   * @since v0.14.0
   * @description
   * Returns the empty representation of a value. Dispatches to the `empty`
   * method on objects or their constructors if it exists. If the value's
   * type does not have an applicable empty representation, undefined is
   * returned.
   *
   * @example
   * empty([1, 2, 3, 4])            // => []
   * empty({ foo: 'bar '})          // => {}
   * empty('hello!')                // => ''
   * empty(0)                       // => undefined
   * empty(false)                   // => undefined
   * empty({ empty: () => 'FOO!' }) // => 'FOO!'
   */
  var empty = _defn('empty', function (a) {
    if (a == null) return void 0
    if (typeof a.empty === 'function') return a.empty()
    if (a.constructor && typeof a.constructor.empty === 'function') {
      return a.constructor.empty()
    }

    switch (typeOf(a)) {
      case 'Array':
        return []
      case 'String':
        return ''
      case 'Object':
        return {}
      default:
        return void 0
    }
  })

  /**
   * @name equals
   * @signature a -> a -> Boolean
   * @since v0.7.0
   * @description
   * Deeply compares two values and returns a boolean indicating whether or
   * not they are equal.
   * @see identical
   *
   * @example
   * equals(5, 5) // => true
   * equals({ name: 'Bill' }, { name: 'Bill' }) // => true
   * equals({ name: 'Bill' }, { name: 'Bob' })  // => false
   *
   * const people = [{ name: 'Bill' }, { name: 'Bob' }]
   * reject(equals({ name: 'Bill' }), people) // => [{ name: 'Bob' }]
   */
  var equals = _defn('equals', _equals)

  /**
   * @name F
   * @signature Any -> Boolean
   * @since v0.16.0
   * @description
   * Always returns false; equivalent to `always(false)`.
   * Use `T` for a true stub.
   * @see T
   *
   * @example
   * times(F, 5) // => [false, false, false, false, false]
   */
  var F = _defn('F', always(false))

  /**
   * @name find
   * @signature (a -> Boolean) -> [a] -> a | undefined
   * @since v0.6.0
   * @description
   * Tests a predicate against a list, returning the first value that
   * matches that predicate. If no matching value is found, `undefined` is
   * returned.
   *
   * @example
   * find(isEven, [1, 3, 4, 6]) // => 4
   * find(isEven, [1, 3, 5, 7]) // => undefined
   * find(propEq('id', 2), [{ id: 1 }, { id : 2 }]) // => { id: 2 }
   */
  var find = _defn('find', function (pred, xs) {
    var i = 0

    for (; i < xs.length; i++) {
      if (pred(xs[i])) {
        return xs[i]
      }
    }
  })

  /**
   * @name findIndex
   * @signature (a -> Boolean) -> [a] -> Number
   * @since v0.1.0
   * @description
   * Tests a predicate against a list, returning the index of the first
   * vakye that matches that predicate. If no matching value is found, `-1` is
   * returned.
   * @see find
   * @see findLast
   *
   * @example
   * find(isEven, [1, 3, 4, 6]) // => 2  (4 is the first even number)
   * find(isEven, [1, 3, 5, 7]) // => -1
   */
  var findIndex = _defn('findIndex', function (pred, xs) {
    var i = 0

    for (; i < xs.length; i++) {
      if (pred(xs[i])) {
        return i
      }
    }
    return -1
  })

  /**
   * @name findLast
   * @signature (a -> Boolean) -> [a] -> a | undefined
   * @since v0.12.0
   * @description
   * Finds and returns the last value in a list that matches the given predicate. If no
   * matching value is found, `undefined` is returned.
   *
   * @example
   * const users = [{ id: 1, name: 'Bob' }, { id: 2, name: 'Bill'}, { id: 3, name: 'Bob' }]
   * findLast(propEq('name', 'Bob'), users) // => { id: 3, name: 'Bob' }
   */
  var findLast = _defn('findLast', function (pred, xs) {
    var i = xs.length - 1

    while (i >= 0) {
      if (pred(xs[i])) {
        return xs[i]
      }
      i--
    }
  })

  /**
   * @name flatten
   * @signature [[a]] -> [a]
   * @since v0.1.0
   * @description
   * Shallowly flattens a list (i.e. 1 level deep).
   * @see flattenDeep
   *
   * @example
   * flatten([1, 2, [3, 4]])   // => [1, 2, 3, 4]
   * flatten([1, 2, [3, [4]]]) // => [1, 2, 3, [4]]
   */
  var flatten = _defn('flatten', function (xs) {
    var acc = []
      , i   = 0
      , x
      , xi

    for (; i < xs.length; i++) {
      x = xs[i]
      if (Array.isArray(x)) {
        for (xi = 0; xi < x.length; xi++) {
          acc.push(x[xi])
        }
      } else {
        acc.push(x)
      }
    }
    return acc
  })

  /**
   * @name flattenDeep
   * @signature [[a]] -> [a]
   * @since v0.5.0
   * @description
   * Deeply flattens a list.
   *
   * @example
   * flattenDeep([1, 2, [3, [4, [5, 6, [7]]]]]) // => [1, 2, 3, 4, 5, 6, 7]
   */
  var flattenDeep = _defn('flattenDeep', function flattenDeep (xs) {
    var acc = []
      , i   = 0
      , x
      , xi

    for (; i < xs.length; i++) {
      x = xs[i]
      if (Array.isArray(x)) {
        x = flattenDeep(x)
        for (xi = 0; xi < x.length; xi++) {
          acc[acc.length] = x[xi]
        }
      } else {
        acc[acc.length] = x
      }
    }
    return acc
  })

  /**
   * @name flip
   * @signature (a -> b -> c -> ... -> z) -> z -> ... -> c -> b -> a
   * @since v0.10.0
   * @description
   * Wraps a function so that when it is invoked its arguments are applied in
   * reverse order. Note that `flip` produces a curried function.
   *
   * @example
   * const fn = flip((a, b, c) => [a, b, c])
   * fn('A', 'B', 'C') // => ['C', 'B', 'A']
   * fn('a')('b')('c') // => ['c', 'b', 'a']
   */
  var flip = _defn('flip', function (fn) {
    return curryN(fn.length, function () {
      return fn.apply(null, _reverse.call(arguments))
    })
  })

  /**
   * @name fmap
   * @signature Functor f => (a -> b) -> f a -> f b
   * @since v0.13.0
   * @description
   * Lifts a function into a functor. The functor must implement either `fmap` or `map`.
   * @example
   * // Tree is a functor that implements `map` (or `fmap`):
   * class Tree {
   *   constructor (value, left, right) {
   *      this._value = value
   *      this._left = left
   *      this._right = right
   *   }
   *   map (fn) {
   *     return new Tree(
   *       fn(this._value),
   *       this._left && this._left.map(fn),
   *       this._right && this._right.map(fn),
   *     )
   *   }
   * }
   * const tree = new Tree(2, new Tree(1), new Tree(3))
   * fmap(double, tree) // => Tree(4, Tree(2), Tree(6))
   *
   * // Native arrays implement `map`:
   * fmap(double, [1, 2, 3, 4]) // => [2, 4, 6, 8]
   */
  var fmap = _defn('fmap', function (fn, functor) {
    if (functor.fmap) return functor.fmap(fn)
    if (functor.map) return functor.map(fn)

    // TODO(zuko): more descriptive error message
    throw new Error('The functor provided to fmap does not implement `map`.')
  })

  function _forEach (fn, xs) {
    var i = 0

    while (i < xs.length) {
      fn(xs[i])
      i++
    }
  }

  /**
   * @name forEach
   * @signature (a -> *) -> [a] -> undefined
   * @since v0.1.0
   * @description
   * Iterates through a list, calling the provided function with each value.
   * The result of the function call is ignored. If you wish to transform
   * each value in the list, use `map`.
   * @see map
   *
   * @example
   * const log = x => console.log(x)
   * const res = forEach(log, [1, 2, 3]) // => logs: 1, 2, 3
   * console.log(res)                    // => undefined
   */
  var forEach = _defn('forEach', _forEach)

  /**
   * @name fromPairs
   * @signature [[k, v]] -> {k:v}
   * @since v0.7.0
   * @description
   * Builds an object out of a list of tuples containing key/value pairs. Note
   * that for duplicate keys, the last key/value pair will be used. If you wish
   * to merge a list of keys with a list of values, use `zip` or `zipObj`.
   * @see toPairs
   *
   * @example
   * fromPairs([['a', 1], ['b', 2]])           // => { a: 1, b: 2 }
   * fromPairs([['a', 1], ['b', 2], ['a', 3]]) // => { a: 3, b: 2 }
   */
  var fromPairs = _defn('fromPairs', function (pairs) {
    var i   = 0
      , acc = {}

    for (; i < pairs.length; i++) {
      acc[pairs[i][0]] = pairs[i][1]
    }

    return acc
  })

  /**
   * @name groupBy
   * @signature
   * String k, Any v => (v -> k) -> [v] -> {k:v}
   * @since v0.18.0
   * @description
   * Creates an object from a list of values where the values are grouped
   * together as a list based on the key returned from the grouping function.
   *
   * @example
   * groupBy(
   *   x => x.age <= 12 ? 'child' : x.age < 18 ? 'teenager' : 'adult',
   *   [{ age: 5 }, { age: 7 }, { age: 21 }, { age: 15 }, { age: 2 }]
   * )
   * // =>
   * // {
   * //   child    : [{ age: 5 }, { age: 7 }, { age: 2 }]
   * // , teenager : [{ age: 15 }]
   * // , adult    : [{ age: 21 }]
   * // }
   */
  var groupBy = _defn('groupBy', function (fn, xs) {
    return _reduce(function (acc, x) {
      var key = fn(x)
      acc[key] = (acc[key] || []).concat(x)
      return acc
    }, {}, xs)
  })

  /**
   * @name gt
   * @signature Number -> Number -> Boolean
   * @since v0.13.0
   * @description
   * Determines whether the second argument is greater than the first. Because
   * infix notation with `>` is generally used when both arguments are known
   * upfront, we optimize for readability with partial application.
   * @see gte
   * @see lt
   * @see lte
   *
   * @example
   * gt(2, 5) // => true (5 is greater than 2)
   * filter(gt(3), [1, 2, 3, 4, 5]) // => [4, 5]
   */
  var gt = _defn('gt', function gt (a, b) {
    return b > a
  })

  /**
   * @name gte
   * @signature Number -> Number -> Boolean
   * @since v0.13.0
   * Determines whether the second argument is greater than or equal to the first.
   * Because infix notation with `>=` is generally used when both arguments are
   * known upfront, we optimize for readability with partial application.
   * @see gt
   * @see lt
   * @see lte
   *
   * @example
   * gte(2, 5) // => true (5 is greater than 2)
   * gte(5, 5) // => true (5 is equal to 5)
   * filter(gte(3), [1, 2, 3, 4, 5]) // => [3, 4, 5]
   */
  var gte = _defn('gte', function (a, b) {
    return b >= a
  })

  /**
   * @name has
   * @signature String k -> {k:v} -> Boolean
   * @since v0.11.0
   * @description
   * Checks whether an object has the provided key as an own property.
   *
   * @example
   * has('name', { name: 'Bill' }) // => true
   *
   * // Ignores inherited properties
   * class A {
   *   foo () {}
   * }
   * const a = new A()
   * has('foo', a) // => false
   */
  var has = _defn('has', function (k, o) {
    return _hasOwn.call(o, k)
  })

  /**
   * @name head
   * @signature [a] -> a
   * @since v0.1.0
   * @description
   * Returns the first element in a list. If the list is empty, `undefined`
   * is returned.
   *
   * @example
   * head([1, 2, 3, 4]) // => [1]
   */
  var head = _defn('head', function (xs) {
    return xs[0]
  })

  /**
   * @name identical
   * @signature a -> a -> Boolean
   * @since v0.13.0
   * @description
   * Checks whether two values are strictly identical. For objects, this test
   * asserts that they reference the same place in memory (think `===`).
   * For deep comparisons, use `equals`.
   * @see equals
   *
   * @example
   * identical(5, 5) // => true
   *
   * // Objects are compared by reference, unlike `equals`.
   * const a = { id: 1 }
   * identical(a, a)         // => true
   * identical(a, { id: 1 }) // => false
   */
  var identical = _defn('identical', _identical)

  /**
   * @name ifElse
   * @signature (a -> Boolean) -> (a -> *) -> (a -> *) -> (a -> *)
   * @since v0.12.0
   * @description
   * Creates a unary function that checks its argument against a predicate and,
   * based on that result, dispatches to either the `whenTrue` or `whenFalse`
   * function. For example, if the predicate is met, the `whenTrue` function
   * will be called and and its result returned; otherwise the `whenFalse`
   * function is called. If you wish to only handle the true condition, use
   * `when`.
   * @see when
   * @example
   * const myFunc = ifElse(isEven, inc, dec)
   * myFunc(2) // => 3
   * myFunc(4) // => 5
   * myFunc(7) // => 6
   */
  var ifElse = _defn('ifElse', function (cond, whenTrue, whenElse) {
    return function (x) {
      return cond(x) ? whenTrue(x) : whenElse(x)
    }
  })

  /**
   * @name inc
   * @signature Number -> Number
   * @since v0.6.0
   * Increments a number by `1`.
   * @see dec
   *
   * @example
   * inc(10) // => 11
   * inc(-1) // => 0
   */
  var inc = _defn('inc', function (a) {
    return a + 1
  })

  /**
   * @name init
   * @signature [a] -> [a]
   * @since v0.17.0
   * @description
   * Returns all but the last element in a list.
   * @see head
   * @see tail
   *
   * @example
   * init([])              // => []
   * init([1])             // => []
   * init([1, 2, 3, 4, 5]) // => [1, 2, 3, 4]
   */
  var init = _defn('init', function (xs) {
    return _slice.call(xs, 0, xs.length - 1)
  })

  /**
   * @name insert
   * @signature Number -> a -> [a] -> [a]
   * @since v0.11.0
   * @description
   * Inserts a value at the given position in a list. This does not replace
   * the current value, but rather shifts it and all following elements forward
   * by one poisition.
   * @see append
   * @see prepend
   *
   * @example
   * insert(1, 5, [0, 1, 2, 3]) // => [0, 5, 1, 2, 3]
   */
  var insert = _defn('insert', function (idx, x, xs) {
    var ys = _slice.call(xs, 0, idx)
    ys[ys.length] = x
    return ys.concat(_slice.call(xs, idx))
  })

  /**
   * @name isEmpty
   * @signature a -> Boolean
   * @since v0.14.0
   * @description
   * Describes whether or not a value is empty. To determine "emptiness", the
   * value is compared against its type's empty representation. Dispatches to
   * the `empty` method on an object if it exists.
   *
   * Note that this is different from checking whether or not a value is falsy.
   * Nil values (null and undefined) are not considered empty, nor is 0, since
   * these are discrete values that cannot contain anything.
   *
   * @example
   * isEmpty('')        // => true
   * isEmpty([])        // => true
   * isEmpty({})        // => true
   * isEmpty(null)      // => false
   * isEmpty(undefined) // => false
   * isEmpty(0)         // => false
   * isEmpty(false)     // => false
   */
  var isEmpty = _defn('isEmpty', function (a) {
    if (a == null) return false
    return _equals(a, empty(a))
  })

  /**
   * @name isEven
   * @signature Number -> Boolean
   * @since v0.14.0
   * @description
   * Returns whether or not a number is even.
   * @see isOdd
   *
   * @example
   * isEven(2)        // => true
   * isEven(0)        // => true
   * isEven(2.4)      // => false
   * isEven(Infinity) // => false
   */
  var isEven = _defn('isEven', function (a) {
    return !isNaN(a) && isFinite(a) && a % 2 === 0
  })

  /**
   * @name isNil
   * @signature a -> Boolean
   * @since v0.11.0
   * @description
   * Determines whether the argument is equal to `undefined` or `null`.
   * This check is strictly for the above values; it does not return `true` for
   * any other falsy value.
   *
   * @example
   * isNil(null)      // => true
   * isNil(undefined) // => true
   * isNil('')        // => false
   * isNil(0)         // => false
   *
   * @param {*} x
   * @returns Boolean
   */
  var isNil = _defn('isNil', function (x) {
    return x == null
  })

  /**
   * @name isOdd
   * @signature Number -> Boolean
   * @since v0.14.0
   * @description
   * Returns whether or not a number is odd.
   * @see isEven
   *
   * @example
   * isOdd(3)        // => true
   * isOdd(0)        // => false
   * isOdd(3.9)      // => false
   * isOdd(Infinity) // => false
   */
  var isOdd = _defn('isOdd', function (a) {
    return !isNaN(a) && isFinite(a) && !!a && a === Math.floor(a) && a % 2 !== 0
  })

  function _Set () {
    this._items = {}
  }

  _Set.prototype.add = function (value) {
    var type = typeof value

    switch (type) {
      case 'boolean':
      case 'number':
      case 'string':
        if (!this._items[type]) {
          this._items[type] = {}
          this._items[type][value] = true
          return true
        }
        if (!this._items[type][value]) {
          this._items[type][value] = true
          return true
        }
        return false
      case 'undefined':
        if (!this._items.undefined) {
          this._items.undefined = true
          return true
        }
        return false
      case 'object':
        if (value == null) {
          if (!this._items.null) {
            this._items.null = true
            return true
          }
          return false
        }
        // intentionally fall through, since we only wanted to handle `null`
      default: // eslint-disable-line
        if (!this._items[type]) {
          this._items[type] = [value]
          return true
        }
        if (!contains$1(value, this._items[type])) {
          this._items[type][this._items[type].length] = value
          return true
        }
        return false
    }
  }

  _Set.prototype.clear = function () {
    this._items = {}
  }

  /**
   * @name intersection
   * @signature [a] -> [a] -> [a]
   * @since v0.19.0
   * @description
   * Returns a list of unique values which occur in both of the input lists.
   *
   * @example
   * intersection([1, 2, 3, 4], [3, 4, 5]) // => [3, 4]
   */
  var intersection = _defn('intersection', function (xs, ys) {
    var i   = 0
      , res = []
      , set = new _Set()
      , lookupList
      , filteredList

    if (xs.length < ys.length) {
      lookupList = ys
      filteredList = xs
    } else {
      filteredList = ys
      lookupList = xs
    }
    for (; i < lookupList.length; i++) {
      set.add(lookupList[i])
    }
    for (i = 0; i < filteredList.length; i++) {
      if (!set.add(filteredList[i])) {
        res[res.length] = filteredList[i]
      }
    }
    return res
  })

  /**
   * @name join
   * @signature String -> [String] -> String
   * @since v0.13.0
   * @description
   * Joins all elements of a list together with the provided string.
   *
   * @example
   * join(' & ', ['Michael', 'Dwight', 'Jim']) // => 'Michael & Dwight & Jim'
   * join('', ['Hello', 'Goodbye'])            // => 'HelloGoodbye'
   */
  var join = _defn('join', function (joiner, xs) {
    return xs.join(joiner)
  })

  function _mapObject (fn, obj) {
    return _reduce(function (acc, key) {
      acc[key] = fn(obj[key])
      return acc
    }, {}, keys$1(obj))
  }

  /**
   * @name map
   * @signature
   * Functor f => (a -> b) -> f a -> f b
   * @since v0.1.0
   * @description
   * Applies a transformation function to all values in a functor. For lists,
   * this means producing a new list where each value has been transformed.
   * For objects, this produces a new object with the same keys where each
   * each own key has had its value transformed.
   * @see mapi
   *
   * @example
   * map(x => x * 2, [1, 2, 3, 4, 5])      // => [2, 4, 6, 8, 10]
   * map(x => x * 2, { a: 1, b: 2, c: 3 }) // => { a: 2, b: 4, c: 6 }
   */
  var map = _defn('map', function (fn, xs) {
    return isType('Object', xs)
      ? _mapObject(fn, xs)
      : _mapList(fn, xs)
  })

  /**
   * @name juxt
   * @signature [(x, y, z... -> a), (x, y, z... -> b), ...] -> (x, y, z...) -> [a, b, ...]
   * @description
   * Applies a set of arguments to a list of functions, returning a list that
   * contains the result of each function call in its corresponding position.
   *
   * @example
   * juxt([inc, dec, multiply(3)])(2)    // => [3, 1, 6]
   * juxt([add, divide, multiply])(2, 4) // => [6, 2, 8]
   */
  var juxt = _defn('juxt', function (fns) {
    return function () {
      var args = _slice.call(arguments)
      return map(function (fn) {
        return fn.apply(null, args)
      }, fns)
    }
  })

  /**
   * @name keys
   * @signature {k:v} -> [k]
   * @since v0.1.0
   * @description
   * Returns a list containing all own enumerable properties of an object.
   * Note that key order is not guaranteed due to discrepencies between
   * JavaScript engines.
   * @see values
   *
   * @example
   * keys({ a: 1, b: 2, c: 3 }) // => ['a', 'b', 'c']
   *
   * // Ignores inherited properties
   * class A {
   *   foo() {}
   * }
   * const a = new A()
   * keys(a) // => []
   * a.bar = () => {}
   * keys(a) // => ['bar']
   */
  var keys = _defn('keys', keys$1)

  /**
   * @name last
   * @signature [a] -> a
   * @since v0.1.0
   * @description
   * Returns the last element in a list. If the list is empty, `undefined` is
   * returned.
   * @see head
   * @see tail
   *
   * @example
   * last([1, 2, 3, 4]) // => 4
   */
  var last = _defn('last', function (xs) {
    return xs[xs.length - 1]
  })

  /**
   * @name length
   * @signature [a] -> Number
   * @since v0.13.0
   * @description
   * Returns the length of a list.
   *
   * @example
   * length([1, 2, 3, 4, 5]) // => 5
   */
  var length = _defn('length', function (xs) {
    return xs.length
  })

  /**
   * @name lens
   * @signature (({k:v} -> v), (v, {k:v} -> {k:v})) -> Lens k
   * @since v0.11.0
   * @description
   * Creates a Lens that knows how to get and set a specific value on an object.
   * This lens can be used with `set`, `over`, and `view` in order to set,
   * transform, and get the value at the lens' focus, respectively.
   * If you want to create a lens focused on a specific property, you can use
   * the convenient `lensProp`.
   * @see lensProp
   * @example
   * const nameLens = lens(obj => obj.name, (value, obj) => assoc('name', value, obj))
   * // shorthand: lens(prop('name'), assoc('name'))
   *
   * view(nameLens, { name: 'Joe' })          // => Joe
   * set(nameLens, 'Bob', { name: 'Joe' })    // => Bob
   * over(nameLens, toUpper, { name: 'Joe' }) // => JOE
   */
  var lens = _defn('lens', function (getter, setter) {
    return {
      get: getter
    , set: setter
    , toString: function () {
      return 'Lens'
    }
    }
  })

  /**
   * @name prop
   * @signature String k -> {k:v} -> v
   * @since v0.1.0
   * @description
   * Returns the value of a given property on an object.
   *
   * @example
   * prop('name', {})              // => undefined
   * prop('name', { name: 'Bob' }) // => Bob
   */
  var prop = _defn('prop', function prop (k, o) {
    return o[k]
  })

  /**
   * @name lensProp
   * @signature String -> Lens
   * @since v0.11.0
   * @description
   * Creates a Lens that is focused on a given property. The getter and setter
   * for the created lens do not mutate the target object.
   * @see lens
   * @see over
   * @see set
   * @see view
   * @example
   * const nameLens = lensProp('name')
   * const bob = { name: 'Bob' }
   *
   * view(nameLens, bob)       // => 'Bob'
   * set(nameLens, 'Joe', bob) // => { name: 'Joe' }
   */
  var lensProp = _defn('lensProp', function (key) {
    return lens(prop(key), assoc(key))
  })

  /**
   * @name lt
   * @signature Number -> Number -> Boolean
   * @since v0.13.0
   * @description
   * Determines whether the second argument is less than the first. Because
   * infix notation with `<` is generally used when both arguments are known
   * upfront, we optimize for readability with partial application.
   * @see gt
   * @see gte
   * @see lte
   *
   * @example
   * lt(2, 1) // => true (1 is less than 2)
   * filter(lt(3), [1, 2, 3, 4, 5]) // => [1, 2]
   */
  var lt = _defn('lt', function (a, b) {
    return b < a
  })

  /**
   * @name lte
   * @signature Number -> Number -> Boolean
   * @since v0.13.0
   * @description
   * Determines whether the second argument is less than or equal to the first.
   * Because infix notation with `<=` is generally used when both arguments are
   * known upfront, we optimize for readability with partial application.
   * @see gt
   * @see gte
   * @see lt
   *
   * @example
   * lte(2, 1) // => true (1 is less than 2)
   * lte(2, 2) // => true (2 is equal to 2)
   * filter(lte(3), [1, 2, 3, 4, 5]) // => [1, 2, 3]
   */
  var lte = _defn('lte', function (a, b) {
    return b <= a
  })

  /**
   * @name mapi
   * @signature ((a, Integer) -> b) -> [a] -> [b]
   * @since v0.16.0
   * @description
   * Applies a transformation function to all elements in a list, returning
   * a new list containing the results of those transformations. This is the
   * same as `map`, but provides the index of the each element as an additional
   * argument to the transformation function.
   * @see map
   *
   * @example
   * const xform = (x, i) => isOdd(i) ? x * 2 : x
   * mapi(xform, [1, 2, 3, 4, 5]) // => [2, 2, 6, 4, 5]
   */
  var mapi = _defn('mapi', function (fn, as) {
    var bs = new Array(as.length)
      , i  = 0

    for (; i < as.length; i++) {
      bs[i] = fn(as[i], i)
    }
    return bs
  })

  /**
   * @name mapKeys
   * @signature (a -> b) -> {a:v} -> {b:v}
   * @since v0.15.0
   * @description
   * Iterates over all own, enumerable keys of an object, transforming each
   * key with the provided function.
   * @see mapValues
   *
   * @example
   * mapKeys(prepend('myKey_'), { a: 1, b: 2 }) // => { myKey_a: 1, myKey_b: 2 }
   */
  var mapKeys = _defn('mapKeys', function (fn, obj) {
    return _reduce(function (acc, key) {
      acc[fn(key)] = obj[key]
      return acc
    }, {}, Object.keys(obj))
  })

  var _match = String.prototype.match

  /**
   * @name match
   * @signature RegExp -> String -> [String]
   * @since v0.19.0
   * @description
   * Returns a list containing all matches for the regular expression. If there
   * are no matches, an empty list is returned.
   *
   * @example
   * match(/foo[a-z]+/g, 'foobar foo bazbiz foobop') // => ['foobar', 'foobop']
   */
  var match = _defn('match', function (regex, str) {
    return _match.call(str, regex) || []
  })

  /**
   * @name max
   * @signature [Number] -> Number
   * @since v0.14.0
   * @description
   * Returns the greatest number from a list of numbers.
   * @see min
   * @example
   * max([1, 2, 3, 4, 5]) // => 5
   */
  var max = _defn('max', function (xs) {
    var i   = xs.length - 1
      , max = xs[i--]

    while (i >= 0) {
      if (xs[i] > max) {
        max = xs[i]
      }
      i--
    }
    return max
  })

  /**
   * @name sum
   * @signature [Number] -> Number
   * @since v0.10.0
   * @description
   * Returns the sum of all elements in a list.
   *
   * @example
   * sum([1, 10, 100]) // => 111
   * sum([])           // => 0
   */
  var sum = _defn('sum', function (xs) {
    var i   = 0
      , sum = 0

    for (; i < xs.length; i++) {
      sum += xs[i]
    }
    return sum
  })

  /**
   * @name mean
   * @signature [Number] -> Number
   * @since v0.14.0
   * @description
   * Returns the mean (average) of all numbers in a list.
   *
   * @example
   * mean([1, 2, 3, 4, 5, 6]) // => 3.5
   */
  var mean = _defn('mean', function (xs) {
    if (!xs.length) {
      throw new Error('Cannot calculate the mean of an empty list.')
    }
    return sum(xs) / xs.length
  })

  function _eachOwn (f, o) {
    for (var k in o) {
      if (_hasOwn.call(o, k)) {
        f(k, o[k])
      }
    }
  }

  /**
   * @name merge
   * @signature {k:v} -> {k:v} -> {k:v}
   * @since v0.4.0
   */
  var merge = _defn('merge', function (a, b) {
    var y = {}
      , f = function (k, v) {
        y[k] = v
      }

    _eachOwn(f, a)
    _eachOwn(f, b)
    return y
  })

  /**
   * @name min
   * @signature [Number] -> Number
   * @since v0.14.0
   * @description
   * Returns the smallest number from a list of numbers.
   * @see min
   * @example
   * min([1, 2, 3, 4, 5]) // => 1
   */
  var min = _defn('min', function (xs) {
    var i   = xs.length - 1
      , min = xs[i--]

    while (i >= 0) {
      if (xs[i] < min) {
        min = xs[i]
      }
      i--
    }
    return min
  })

  /**
   * @name multiply
   * @signature Number -> Number -> Number
   * @since v0.14.0
   * @description
   * Returns the product of two numbers.
   *
   * @example
   * multiply(2, 3) // => 6
   * map(multiply(2), [1, 2, 3, 4]) // => [2, 4, 6, 8]
   */
  var multiply = _defn('multiply', function (a, b) {
    return a * b
  })

  /**
   * @name of
   * @signature a -> [a]
   * @since v0.7.0
   * @description
   * Unary function that returns the argument wrapped in an array.
   *
   * @example
   * of(1)   // => [1]
   * of([1]) // => [[1]]
   */
  var of = _defn('of', function (x) {
    return [x]
  })

  /**
   * @name omit
   * @signature String k, Any v => [k] -> {k:v} -> {k:v}
   * @since v0.14.0
   * @description
   * @see pick
   *
   * @example
   * omit(['a', 'b'], { a: 1, b: 2, c: 3, d: 4 }) // => { c: 3, d: 4 }
   */
  var omit = _defn('omit', function (keys, a) {
    var res = {}
      , prop
      , discard
      , i

    for (prop in a) {
      discard = false
      for (i = 0; i < keys.length; i++) {
        if (keys[i] === prop) {
          discard = true
          break
        }
      }
      if (!discard) {
        res[prop] = a[prop]
      }
    }
    return res
  })

  /**
   * @name set
   * @signature Lens k -> v -> {k:v} -> {k:v}
   * @since v0.11.0
   * @description
   * Applies a value to the target of a lens and returns the result of the lens'
   * setter.
   *
   * @example
   * const nameLens = lensProp('name')
   * const userA = { name: 'Joe' }
   * const userB = set(nameLens, 'Billy', userA)
   *
   * console.log(userA) // => { name: 'Joe' }
   * console.log(userB) // => { name: 'Billy' }
   */
  var set = _defn('set', function (lens, value, target) {
    return lens.set(value, target)
  })

  /**
   * @name over
   * @signature Lens k -> (v -> *) -> {k:v} -> {k:v}
   * @since v0.11.0
   * @description
   * Transforms the value at the focal point of a lens on a given object.
   * @see over
   * @see view
   *
   * @example
   * const nameLens = lensProp('name')
   * const user = { name: 'Michael' }
   *
   * over(lensProp('name'), toUpper, user) // => { name: 'MICHAEL' }
   * console.log(user)                     // => { name: 'Michael' }
   */
  var over = _defn('over', function (lens, fn, target) {
    return set(lens, fn(lens.get(target)), target)
  })

  /**
   * @name padLeft
   * @signature Integer -> String -> String -> String
   * @since v0.19.0
   * @description
   * Pads a string to a given length by prepending it with the given character
   * until that length is reached.
   *
   * @example
   * padLeft(5, 'X', 'hi') // => 'XXXhi'
   */
  // TODO(zuko): how should we handle char of length > 1?
  // TODO(zuko): throw error if char is empty?
  var padLeft = _defn('padLeft', function (length, char, str) {
    while (str.length < length) {
      str = char + str
    }
    return str
  })

  /**
   * @name padRight
   * @signature Integer -> String -> String -> String
   * @since v0.19.0
   * @description
   * Pads a string to a given length by appending the given character to it
   * until that length is reached.
   *
   * @example
   * padRight(5, 'X', 'hi') // => 'hiXXX'
   */
  // TODO(zuko): how should we handle char of length > 1?
  // TODO(zuko): throw error if char is empty?
  var padRight = _defn('padRight', function (length, char, str) {
    while (str.length < length) {
      str += char
    }
    return str
  })

  /**
   * @name pad
   * @signature Integer -> String -> String -> String
   * @since v0.19.0
   * @description
   * Pads a string to a given length by alternating prepending/appending
   * the given character until that length is reached.
   *
   * @example
   * pad(5, 'X', 'hi') // => 'XXhiX'
   */
  var pad = _defn('pad', function (length, char, str) {
    var leftPadding = str.length + Math.ceil((length - str.length) / 2)
    return padRight(length, char, padLeft(leftPadding, char, str))
  })

  /**
   * @name pair
   * @signature a -> b -> [a, b]
   * @since v0.13.0
   * @description
   * Binary function that returns the two arguments as a tuple.
   *
   * @example
   * pair(1, 2) // => [1, 2]
   */
  var pair = _defn('pair', function (a, b) {
    return [a, b]
  })

  /**
   * @name partition
   * @signature (a -> Boolean) -> [a] -> [[a]]
   * @since v0.16.0
   * @description
   * Partitions a list into two lists based on a predicate; the left contains
   * all values that matched the predicate, while the right includes those which
   * did not.
   *
   * @example
   * partition(isEven, [1, 2, 3, 4, 5]) // => [[2, 4], [1, 3, 5]]
   */
  var partition = _defn('partition', function (pred, xs) {
    var left  = []
      , right = []
      , i     = 0

    for (; i < xs.length; i++) {
      if (pred(xs[i])) {
        left[left.length] = xs[i]
      } else {
        right[right.length] = xs[i]
      }
    }
    return [left, right]
  })

  /**
   * @name path
   * @signature String k => [k] -> {k:v} -> v
   * @since v0.17.0
   * @description
   * Returns the value at the given path in an object. If any prop in the series
   * does not exist, the function short circuits and returns `undefined`.
   *
   * @example
   * const getAge = path(['info', 'age'])
   *
   * getAge({ info: { age: 20 }}) // => 20
   * getAge({})                   // => undefined
   */
  var path = _defn('path', function (props, obj) {
    var i   = 0
      , val = obj

    if (val == null) {
      throw new TypeError(
        'The second argument to `path` must not be undefined or null.'
      )
    }

    while (i < props.length) {
      if (val == null) return val
      val = val[props[i]]
      i += 1
    }
    return val
  })

  /**
   * @name pick
   * @signature String k, Any v => [k] -> {k:v} -> {k:v}
   * @since v0.15.0
   * @description
   * Creates a new object that contains only the requested keys from the target
   * object. This is the reverse of `omit`.
   * @see omit
   *
   * @example
   * pick(['first', 'last'], { first: 'Michael', last: 'Scott', age: 35 })
   * // => { first: 'Michael', last: 'Scott' }
   */
  var pick = _defn('pick', function (keys, obj) {
    var i   = 0
      , res = {}

    while (i < keys.length) {
      res[keys[i]] = obj[keys[i]]
      i++
    }
    return res
  })

  /**
   * @name prepend
   * @signature a -> [a] -> a | String -> String -> String
   * @since v0.14.0
   */
  var prepend = _defn('prepend', function (a, as) {
    if (typeof as === 'string') {
      return a + as
    }
    return _concat.call([a], as)
  })

  /**
   * @name propEq
   * @signature String k -> v -> {k:v} -> Boolean
   * @since v0.1.0
   * @description
   * Gets the value of a given property off of an object and returns
   * whether or not it equals the target value. A deep comparison is
   * used to determine equality.
   *
   * @example
   * propEq('name', 'Michael', { name: 'Michael' }) // => true
   * propEq('data', { id: 1 }, { data: { id: 1 }})  // => true
   */
  var propEq = _defn('propEq', function (k, v, o) {
    return _equals(o[k], v)
  })

  /**
   * @name rangeBy
   * @signature Number -> Number -> Number -> [Number]
   * @since v0.7.0
   * @description
   * Returns containing all numbers between at an initial value (inclusive)
   * and an end value (exclusive), where each subsequent value has been
   * incremented by the provided step.
   * @see range
   *
   * @example
   * rangeBy(4, 0, 17) // => [0, 4, 8, 12, 16]
   */
  var rangeBy = _defn('rangeBy', function (inc, start, end) {
    var ys = []
      , times
      , i

    if (inc === 0) {
      throw new Error(
        'The `increment` value provided to `rangeBy` must be a non-zero number.'
      )
    } else if (start === end) {
      throw new Error(
        'The `start` value provided to `rangeBy` must be greater than or less than ' +
        'the `end` value. Received the same value for both: ' + start + '.'
      )
    } else if (inc > 0 && start > end) {
      throw new Error(
        'The `increment` value provided to `rangeBy` must be negative when ' +
        'the start value (' + start + ') is greater than the end value (' +
        end + '). Received: ' + inc + '.'
      )
    } else if (inc < 0 && start < end) {
      throw new Error(
        'The `increment` value provided to `rangeBy` must be positive when ' +
        'the start value (' + start + ') is less than the end value (' +
        end + '). Received: ' + inc + '.'
      )
    }

    times = Math.abs(Math.ceil((end - start) / inc))
    for (i = 0; i < times; i++) {
      ys.push(start + (inc * i))
    }
    return ys
  })

  /**
   * @name range
   * @signature Integer -> Integer -> [Integer]
   * @since v0.7.0
   * @description
   * Returns containing all integers between at an initial value (inclusive)
   * and an end value (exclusive). If you wish to specify a custom step, use
   * `rangeBy`.
   * @see rangeBy
   *
   * @example
   * range(1, 5)  // => [1, 2, 3, 4]
   * range(0, -5) // => [0, -1, -2, -3, -4]
   */
  var range = _defn('range', function (start, end) {
    if (start < end) return rangeBy(1, start, end)
    if (start > end) return rangeBy(-1, start, end)
    throw new Error(
      'The `start` value provided to `range` must be greater than or less ' +
      'than the `end` value. Received the same value for both: ' + start + '.'
    )
  })

  /**
   * @name reduce
   * @signature ((b, a) -> b) -> b -> [a] -> b
   * @since v0.1.0
   * @description
   * Reduces a list of values into a single value. Provided with a reducing
   * function and initial accumulator value, this is accomplished by iterating
   * through all elements of the list (from left -> right) and calling the
   * reducing function with the current acumulator value and the next value in
   * the list. The result of each function call is used as the accumulator in
   * the next call. When the end of the list is reached, the final accumulator
   * value is returned.
   * If you wish to reduce the list from right -> left, use `reduceRight`.
   * @see reduceRight
   * @see scan
   * @alias foldl
   * @example
   * const sum = reduce((acc, n) => acc + n, 0)
   * sum([1, 2, 3, 4, 5]) // => 15
   */
  var reduce = _defn('reduce', _reduce)

  /**
   * @name reduceRight
   * @signature ((b, a) -> b) -> b -> [a]
   * @since v0.1.0
   * @description
   * The same as `reduce`, but runs the reducing function from right -> left.
   *
   * Reduces a list of values into a single value. Provided with a reducing
   * function and initial accumulator value, this is accomplished by iterating
   * through all elements of the list (from right -> left) and calling the
   * reducing function with the current acumulator value and the next value in
   * the list. The result of each function call is used as the accumulator in
   * the next call. When the head of the list is reached, the final accumulator
   * value is returned.
   * If you wish to reduce the list from left -> right, use `reduce`.
   * @see reduce
   * @alias foldr
   * @example
   * const reverse = reduce((acc, x) => [x].concat(acc), [])
   * reverse([1, 2, 3, 4]) // => [4, 3, 2, 1]
   */
  var reduceRight = _defn('reduceRight', function (fn, y, xs) {
    return _reduce(fn, y, _reverse.call(xs))
  })

  /**
   * @name reject
   * @signature
   * (a -> Boolean) -> [a] -> [a]
   * String k, Any v => (v -> Boolean) -> {k:v} -> {k:v}
   * @since v0.1.0
   * @description
   * Returns a subset of a list which excludes all items for which the
   * predicate function returned true. This is the inverse of `filter` and is
   * equivalent to `filter(complement(predicate))`.
   *
   * @example
   * reject(isEven, [1, 2, 3, 4, 5]) // => [1, 3, 5]
   */
  var reject = _defn('reject', function (pred, xs) {
    return filter(complement(pred), xs)
  })

  /**
   * @name replace
   * @signature
   * String|RegExp -> String -> String
   * @since v0.17.0
   * @description
   * Replaces a matched string/regular expression in a string with another value.
   *
   * @example
   * replace('Scott', 'Schrute', 'Dwight Scott') // => 'Dwight Schrute'
   * replace(/hi/g, 'hey', 'hi hi hi')           // => 'hey hey hey'
   */
  var replace = _defn('replace', function (match, value, str) {
    return str.replace(match, value)
  })

  /**
   * @name reverse
   * @signature [a] -> [a]
   * @since v0.1.0
   * @description
   * Reverses the order of elements in a list.
   *
   * @example
   * reverse([1, 2, 3, 4]) // => [4, 3, 2, 1]
   */
  var reverse = _defn('reverse', function (xs) {
    return _reverse.call(_slice.call(xs))
  })

  /**
   * @name scan
   * @signature (b, a -> b) -> b -> [a] -> [b]
   * @since v0.12.0
   * @description
   * Similar to reduce, but, instead of returning the final accumulator value,
   * returns a list containing each iteration of the accumulator.
   * @see reduce
   *
   * @example
   * // initial accumulator  --> 0
   * // first step:  0 + 1   --> 1
   * // second step: 1 + 2   --> 3
   * // third step:  3 + 3   --> 6
   * // fourth step: 6 + 4   --> 10
   * scan(add, 0, [1, 2, 3, 4]) // => [0, 1, 3, 6, 10]
   */
  var scan = _defn('scan', function (fn, acc, xs) {
    var i   = 0
      , res = [acc]

    for (; i < xs.length; i++) {
      acc = fn(acc, xs[i])
      res[res.length] = acc
    }
    return res
  })

  /**
   * @name split
   * @signature String -> String -> [String]
   * @since v0.10.0
   * @description
   * Splits a string on some delimeter and returns a list containing the
   * fragments of that string between the delimeter.
   * @see join
   *
   * @example
   * split(', ', 'Jim, Bill, Bob') // => ['Jim', 'Bill', 'Bob']
   */
  var split = _defn('split', function (char, str) {
    return str.split(char)
  })

  /**
   * @name subtract
   * @signature Number -> Number -> Number
   * @since v0.13.0
   * @description
   * Returns the difference of two numbers. Because infix notation with `-` is
   * generally used when both arguments are known upfront, we optimize for
   * readability with partial application.
   * @see add
   *
   * @example
   * subtract(2, 5) // => 3 (5 - 2)
   *
   * @example
   * const subtract5 = subtract(5)
   * subtract5(10) // => 5
   * subtract5(15) // => 10
   */
  var subtract = _defn('subtract', function (a, b) {
    return b - a
  })

  /**
   * @name T
   * @signature Any -> Boolean
   * @since v0.16.0
   * @description
   * Always returns true; equivalent to `always(true)`.
   * Commonly used as the last predicate in a condition (`cond`) to handle
   * unmatched cases. Use `F` for a false stub.
   * @see F
   *
   * @example
   * times(T, 5) // => [true, true, true, true, true]
   */
  var T = _defn('T', always(true))

  /**
   * @name tail
   * @signature [a] -> [a]
   * @since v0.1.0
   * @description
   * Returns a subset of a list containing all elements except the first. If
   * the list is empty or has only one element, an empty list is returned.
   *
   * @example
   * tail([1, 2, 3, 4, 5]) // => [2, 3, 4, 5]
   * tail([1])             // => []
   * tail([])              // => []
   */
  var tail = _defn('tail', function (xs) {
    return _slice.call(xs, 1)
  })

  /**
   * @name take
   * @signature Integer -> [a] -> [a]
   * @since v0.1.0
   * @description
   * Returns a list containing the first N elements of the target list.
   * If N is greater than the length of the list, all elements are returned.
   * @see drop
   * @see takeWhile
   * @see takeUntil
   *
   * @example
   * take(3, [1, 2, 3, 4, 5]) // => [1, 2, 3]
   * take(5, [1, 2, 3])       // => [1, 2, 3]
   * take(Infinity, [])       // => []
   */
  var take = _defn('take', function (n, xs) {
    return _slice.call(xs, 0, n)
  })

  /**
   * @name takeWhile
   * @signature (a -> Boolean) -> [a] -> [a]
   * @since v0.12.0
   * @description
   * Returns a list containing values from the original list up until the
   * point at which the predicate returned false. This is done by iterating
   * through the original list and testing each value in turn against the
   * predicate function; as soon as the predicate returns false, all future
   * values are discarded, and only the values before the one that failed are
   * selected.
   * If the predicate function holds true for all values in the list, a copy
   * of the entire list is returned.
   * @see takeUntil
   *
   * @example
   * takeWhile(isEven, [2, 4, 6, 7, 8]) // => [2, 4, 6]
   */
  var takeWhile = _defn('takeWhile', function (fn, xs) {
    var i = 0

    for (; i < xs.length; i++) {
      if (!fn(xs[i])) {
        return _slice.call(xs, 0, i)
      }
    }
    return _slice.call(xs)
  })

  /**
   * @name takeUntil
   * @signature (a -> Boolean) -> [a] -> [a]
   * @since v0.12.0
   * @description
   * Selects values from the input list by comparing them against the predicate.
   * Values are included in the output list so long as they do not fulfill the
   * predicate. Once the predicate returns true, that value and the rest of
   * the list is discarded.
   *
   * If the predicate never returns true, a copy of the entire list is returned.
   * @see takeWhile
   *
   * @example
   * takeUntil(isEven, [1, 3, 5, 2, 7]) // => [1, 3, 5]
   */
  var takeUntil = _defn('takeUntil', function (fn, xs) {
    return takeWhile(complement(fn), xs)
  })

  /**
   * @name tap
   * @signature (a -> *) -> a -> a
   * @since v0.7.0
   * @description
   * Wraps a unary function so that it is called as normal but its return value
   * is ignored. This is useful when you want to perform a side effect without
   * interfering with an argument or composition.
   *
   * @example
   * const log = tap(x => console.log(x))
   *
   * // logs: 1, 2, 2, 4, 3, 6, 4, 8
   * map(pipe([log, multiply(2), log]), [1, 2, 3, 4]) // => [2, 4, 6, 8]
   */
  var tap = _defn('tap', function (fn) {
    return function (a) {
      fn(a)
      return a
    }
  })

  /**
   * @name test
   * @signature RegExp -> String -> Boolean
   * @since v0.14.0
   * @description
   * Returns whether or not a string is matched by a regular expression.
   *
   * @example
   * test(/bar/, 'foobarbaz') // => true
   * filter(test(/joe/i), ['Joe', 'Bill', 'joey']) // => ['Joe', 'joey']
   */
  var test = _defn('test', function (regex, str) {
    return regex.test(str)
  })

  /**
   * @name times
   * @signature (Number -> a) -> Number -> [a]
   * @since v0.5.0
   * @description
   * Calls a function N times with the index of each call as its argument.
   * Returns a list containing the result of each function call.
   * @see range
   *
   * @example
   * times(identity, 5) // => [0, 1, 2, 3, 4]
   */
  var times = _defn('times', function (fn, n) {
    var i  = 0
      , bs = []

    for (; i < n; i++) {
      bs.push(fn(i))
    }
    return bs
  })

  /**
   * @name toLower
   * @signature String -> String
   * @since v0.4.0
   * @description
   * Lower-cases all characters in a string.
   * @see toUpper
   *
   * @example
   * toLower('Hi There')  // => 'hi there'
   * toLower('GoodBye')   // => 'goodbye'
   */
  var toLower = _defn('toLower', function toLower (a) {
    return a.toLowerCase()
  })

  /**
   * @name toUpper
   * @signature String -> String
   * @since v0.4.0
   * @description
   * Upper-cases all characters in a string.
   * @see toLower
   *
   * @example
   * toUpper('hi there')  // => 'HI THERE'
   * toUpper('GoodBye')   // => 'GOODBYE'
   */
  var toUpper = _defn('toUpper', function toUpper (a) {
    return a.toUpperCase()
  })

  /**
   * @name toPairs
   * @signature String k, Any v => {k:v} -> [[k, v]]
   * @since v0.7.0
   * @description
   * Converts all own enumerable keys in an object into a list of [key, value] pairs.
   * If you have a list of these pairs and wish to conver them back into an object,
   * use `fromPairs`.
   * @see fromPairs
   *
   * @example
   * toPairs({ a: 'foo', b: 'bar' }) // => [['a', 'foo'], ['b', 'bar']]
   */
  var toPairs = _defn('toPairs', function toPairs (o) {
    var kvs = []

    _eachOwn(function (k, v) {
      kvs.push([k, v])
    }, o)
    return kvs
  })

  /**
   * @name trace
   * @signature String -> a -> a
   * @since v0.18.0
   * @description
   * Creates a unary function that will log out the provided message along with its
   * argument before returning that argument unmodified. This performs a side-effect
   * (logging) and is useful for debugging composed functions by allowing you to
   * trace how values change over time. Trace is solely meant as developer utility.
   * @example
   * map(pipe([
   *   add(1),
   *   trace('value after add'),
   *   multiply(2),
   *   trace('value after multiply')
   * ]), [1, 2, 3, 4])
   * // => [4, 6, 8, 10]
   * // Logs:
   * // value after add 2
   * // value after add 3
   * // ...
   * // value after multiply 10
   */
  var trace = _defn('trace', function (message) {
    return _nameFunc(_createFnName('trace', [message]), tap(function (x) {
      console.log(message, x)
    }))
  })

  /**
   * @name transform
   * @signature String k, Any v => {k: (v -> v)} -> {k:v} -> {k:v}
   * @since v0.18.0
   * @description
   * Recursively applies property-based transforms to the target object's own
   * properties. Transforms defined for non-existent properties are ignored,
   * and properties without a corresponding transform are passed through
   * unmodified.
   * @example
   * transform(
   *   { name: toUpper, details: { location: toUpper } },
   *   {
   *     name: 'joe',
   *     details: {
   *       age: 20,
   *       location: 'usa'
   *     }
   *   }
   * ) // => { name: 'JOE', details: { age: 40, location: 'USA' } }
   */
  var transform = _defn('transform', function transform (transforms, obj) {
    var res = {}
      , prop

    for (prop in obj) {
      if (_hasOwn.call(obj, prop) && _hasOwn.call(transforms, prop)) {
        if (typeof transforms[prop] === 'object') {
          res[prop] = transform(transforms[prop], obj[prop])
        } else if (typeof transforms[prop] === 'function') {
          res[prop] = transforms[prop](obj[prop])
        } else {
          throw new Error(
            'Invalid transformation supplied under the key "' + prop + '". ' +
            'Transformation must be either a function or object, but was ' +
            '"' + typeof transforms[prop] + '".'
          )
        }
      } else {
        res[prop] = obj[prop]
      }
    }
    return res
  })

  /**
   * @name trim
   * @signature String -> String
   * @since v0.13.0
   * @description
   * Returns the string with all leading and trailing whitespace removed.
   *
   * @example
   * trim('  hello  ') // => 'hello'
   */
  var trim = _defn('trim', function (a) {
    return a.trim()
  })

  /**
   * @name unique
   * @signature [a] -> [a]
   * @since v0.19.0
   * @description
   * Returns a new list with all duplicate values removed. Objects are compared
   * by value and not by reference.
   *
   * @example
   * unique([1, 1, 2, 2, 3, 3]) // => [1, 2, 3]
   */
  var unique = _defn('unique', function (xs) {
    var i   = 0
      , res = []
      , set = new _Set()

    for (; i < xs.length; i++) {
      if (set.add(xs[i])) {
        res[res.length] = xs[i]
      }
    }
    set.clear()
    return res
  })

  /**
   * @name when
   * @signature (a -> Boolean) -> (a -> b) -> a -> a | b
   * @since v0.14.0
   * @description
   * Creates a unary function that, when invoked, checks its argument against
   * the predicate function. If the predicate returns true, the handler function
   * is called and its result returned. If the predicate returns false, the
   * original argument is returned unmodified.
   * You can think of `when` as shorthand for `ifElse(predicate, xform, identity)`,
   * though keep in mind that it only supports unary functions.
   * @see ifElse
   * @see unless
   * @example
   * const doubleIfEven = when(isEven, multiply(2))
   *
   * doubleIfEven(4) // => 8
   * doubleIfEven(5) // => 5
   * map(doubleIfEven, [1, 2, 3, 4, 5]) // => [1, 4, 3, 8, 5]
   */
  var when = _defn('when', function (pred, fn) {
    return function (x) {
      return pred(x) ? fn(x) : x
    }
  })

  /**
   * @name unless
   * @signature (a -> Boolean) -> (a -> b) -> a -> a | b
   * @since v0.14.0
   * @description
   * Creates a unary function that dispatches to the provided function
   * if the predicate returns false for the provided value. If the predicate
   * returns true the argument is passed through unmodified.
   * This is the complement of `when`.
   * @see when
   * @see ifElse
   *
   * @example
   * const doubleIfNotEven = unless(isEven, multiply(2))
   * doubleIfNotEven(3) // => 6
   * doubleIfNotEven(2) // => 2
   */
  var unless = _defn('unless', function (pred, fn) {
    return when(complement(pred), fn)
  })

  /**
   * @name values
   * @signature String k, Any v => {k:v} -> [v]
   * @since v0.14.0
   * @description
   * Returns a list containing the values of an object's own enumerable properties.
   * Note that this ignores all inherited properties, and does not guarantee
   * order due to discrepencies between JavaScript engines.
   *
   * @example
   * values({ a: 1, b: 2, c: 3 }) // => [1, 2, 3]
   * values({})                   // => []
   *
   * // Inherited properties are ignored
   * class A {
   *   foo() {}
   * }
   * const a = new A()
   * a.bar = 'BAR'
   * values(a) // => ['BAR'] (foo is inherited from A's protoype and is ignored)
   */
  var values = _defn('values', function (obj) {
    var keys   = Object.keys(obj)
      , i      = 0
      , values = new Array(keys.length)

    while (i < keys.length) {
      values[i] = obj[keys[i]]
      i += 1
    }
    return values
  })

  /**
   * @name view
   * @signature Lens k -> {k:v} -> v
   * @since v0.11.0
   * @description
   * Returns the value at the focal point of a lens on a given object.
   * @see set
   * @see over
   *
   * @example
   * const nameLens = lensProp('name')
   * view(nameLens, { name: 'Dwight' })  // => 'Dwight'
   * view(nameLens, { name: 'Michael' }) // => 'Michael'
   */
  var view = _defn('view', function (lens, target) {
    return lens.get(target)
  })

  /**
   * @name where
   * @signature String k, (Any -> Boolean) Spec => {k:Spec} -> Boolean
   * @since v0.15.0
   * @description
   * @example
   * const pred = where({ name: equals('Michael') })
   * pred({ name: 'Michael' }) // => true
   * pred({ name: 'Dwight' })  // => false
   *
   * const people = [{ age: 12 }, { age: 14 }, { age: 18 }, { age: 22 }]
   * filter(where({ age: gte(18) }), people) // => [{ age: 18 }, { age: 22 }]
   */
  var where = _defn('where', function (spec, obj) {
    var prop

    for (prop in spec) {
      if (
        _hasOwn.call(spec, prop) &&
        !spec[prop](obj[prop])
      ) return false
    }
    return true
  })

  /**
   * @name without
   * @signature [a] -> [a] -> [a]
   * @since v0.7.0
   * @description
   * Excludes all elements of the first list from the second list.
   *
   * @example
   * without([1, 2], [1, 2, 3, 4, 2, 1, 7]) // => [3, 4, 7]
   */
  var without = _defn('without', function (as, bs) {
    var i   = 0
      , res = []

    while (i < bs.length) {
      if (!contains$1(bs[i], as)) {
        res[res.length] = bs[i]
      }
      i++
    }
    return res
  })

  /**
   * @name zip
   * @signature [a] -> [b] -> [[a, b]]
   * @since v0.3.0
   * @description
   * Returns a list of tuples generated by pairing elements of the first
   * list with elements of the second list, by position. The result
   * is truncated to the length of the shorter of the two input lists.
   * @see zipObj
   *
   * @example
   * zip(['a', 'b', 'c'], [1, 2, 3]) // => [['a', 1], ['b', 2], ['c', 3]]
   * zip(['a', 'b', 'c'], [1])       // => [['a', 1]]
   */
  var zip = _defn('zip', function (as, bs) {
    var i   = 0
      , len = Math.min(as.length, bs.length)
      , abs = new Array(len)

    for (; i < len; i++) {
      abs[i] = [as[i], bs[i]]
    }
    return abs
  })

  /**
   * @name zipObj
   * @signature String k, Any v => [k] -> [v] -> {k:v}
   * @since v0.3.0
   * @description
   * Returns an object with keys/values generated by pairing elements of
   * the first list (of keys) with elements of the second list (of values)
   * by their position. The result is truncated to the length of the shorter
   * of the two input lists.
   * If you wish to zip  nlist of `[key, value]` pairs, use `fromPairs`.
   * @see fromPairs
   * @see zip
   *
   * @example
   * zipObj(['a', 'b', 'c'], [1, 2, 3]) // => { a: 1, b: 2, c: 3 }
   * zipObj(['a', 'b', 'c'], [1])       // => { a: 1 }
   */
  var zipObj = _defn('zipObj', function (ks, vs) {
    var i   = 0
      , len = Math.min(ks.length, vs.length)
      , kv  = {}

    for (; i < len; i++) {
      kv[ks[i]] = vs[i]
    }
    return kv
  })

  exports.add = add;
  exports.all = all;
  exports.always = always;
  exports.any = any;
  exports.append = append;
  exports.assoc = assoc;
  exports.chain = chain;
  exports.clamp = clamp;
  exports.concat = concat;
  exports.cond = cond;
  exports.contains = contains;
  exports.compact = compact;
  exports.complement = complement;
  exports.compose = compose;
  exports.curry = curry;
  exports.curryN = curryN;
  exports.dec = dec;
  exports.dissoc = dissoc;
  exports.divide = divide;
  exports.drop = drop;
  exports.dropUntil = dropUntil;
  exports.dropWhile = dropWhile;
  exports.empty = empty;
  exports.equals = equals;
  exports.F = F;
  exports.filter = filter;
  exports.find = find;
  exports.findIndex = findIndex;
  exports.findLast = findLast;
  exports.flatMap = chain;
  exports.flatten = flatten;
  exports.flattenDeep = flattenDeep;
  exports.flip = flip;
  exports.fmap = fmap;
  exports.forEach = forEach;
  exports.fromPairs = fromPairs;
  exports.groupBy = groupBy;
  exports.gt = gt;
  exports.gte = gte;
  exports.has = has;
  exports.head = head;
  exports.identical = identical;
  exports.identity = identity;
  exports.ifElse = ifElse;
  exports.inc = inc;
  exports.init = init;
  exports.insert = insert;
  exports.isEmpty = isEmpty;
  exports.isEven = isEven;
  exports.isNil = isNil;
  exports.isOdd = isOdd;
  exports.isType = isType;
  exports.intersection = intersection;
  exports.join = join;
  exports.juxt = juxt;
  exports.keys = keys;
  exports.last = last;
  exports.length = length;
  exports.lens = lens;
  exports.lensProp = lensProp;
  exports.lt = lt;
  exports.lte = lte;
  exports.map = map;
  exports.mapi = mapi;
  exports.mapKeys = mapKeys;
  exports.match = match;
  exports.max = max;
  exports.mean = mean;
  exports.merge = merge;
  exports.min = min;
  exports.multiply = multiply;
  exports.of = of;
  exports.omit = omit;
  exports.over = over;
  exports.pad = pad;
  exports.padLeft = padLeft;
  exports.padRight = padRight;
  exports.pair = pair;
  exports.partition = partition;
  exports.path = path;
  exports.pick = pick;
  exports.pipe = pipe;
  exports.prepend = prepend;
  exports.prop = prop;
  exports.propEq = propEq;
  exports.range = range;
  exports.rangeBy = rangeBy;
  exports.reduce = reduce;
  exports.foldl = reduce;
  exports.reduceRight = reduceRight;
  exports.foldr = reduceRight;
  exports.reject = reject;
  exports.replace = replace;
  exports.reverse = reverse;
  exports.scan = scan;
  exports.set = set;
  exports.split = split;
  exports.subtract = subtract;
  exports.sum = sum;
  exports.T = T;
  exports.tail = tail;
  exports.take = take;
  exports.takeUntil = takeUntil;
  exports.takeWhile = takeWhile;
  exports.tap = tap;
  exports.test = test;
  exports.times = times;
  exports.toLower = toLower;
  exports.toUpper = toUpper;
  exports.toPairs = toPairs;
  exports.trace = trace;
  exports.transform = transform;
  exports.trim = trim;
  exports.type = typeOf;
  exports.unique = unique;
  exports.unless = unless;
  exports.values = values;
  exports.view = view;
  exports.when = when;
  exports.where = where;
  exports.without = without;
  exports.zip = zip;
  exports.zipObj = zipObj;

}));